---
layout: post
title:  "常见排序算法"
date:   2022-02-16 12:16:00 PM +0800
category: Algorithm
---

# 排序算法

- [排序算法](#排序算法)
  - [1 排序算法中的基本概念](#1-排序算法中的基本概念)
    - [1.1 排序算法的稳定性](#11-排序算法的稳定性)
    - [1.2 时间复杂度](#12-时间复杂度)
    - [1.3 空间复杂度](#13-空间复杂度)
    - [1.4 分治法（Divide and Conquer](#14-分治法divide-and-conquer)
  - [2 排序算法](#2-排序算法)
    - [2.1 冒泡排序（Bubble Sort）](#21-冒泡排序bubble-sort)
    - [2.2 选择排序（Selection Sort）](#22-选择排序selection-sort)
    - [2.3 插入排序（Insertion Sort）](#23-插入排序insertion-sort)
    - [2.4 归并排序（Merge Sort）](#24-归并排序merge-sort)
    - [2.5 快速排序（Quick Sort）](#25-快速排序quick-sort)
    - [2.6 堆排序（Heap Sort）](#26-堆排序heap-sort)
    - [2.7 希尔排序（Shell Sort）](#27-希尔排序shell-sort)
    - [2.8 计数排序（Counting Sort）](#28-计数排序counting-sort)
    - [2.9 桶排序（Bucket Sort）](#29-桶排序bucket-sort)
    - [2.10 基数排序（Radix Sort）](#210-基数排序radix-sort)
  - [参考](#参考)

## 1 排序算法中的基本概念

### 1.1 排序算法的稳定性

假设在待排序的数列中，存在多个具有相同值的元素，经过排序后，这些元素的相对顺序保持不变（例如， `arr[i] = arr[j]` ，且 `arr[i]` 在 `arr[j]` 之前，排序后， `arr[i]` 仍在 `arr[j]` 之前），则称这种排序算法是稳定的，否则称为不稳定的。

### 1.2 时间复杂度

排序算法的时间复杂度是一种理论上的度量，用于描述算法在处理数据时所需的时间随输入规模的变化情况。它通常用 **“大O符号”** 表示，反映了算法在 **最坏** 、 **平均** 或 **最好** 情况下的效率。时间复杂度关注的是输入规模（通常用 `n` 表示）对算法运行时间的影响，而不是具体的运行时间，以便提供一种比较不同算法效率的标准。

以下是时间复杂度的一些常见类型：

- **常数时间复杂度：O(1)**  
   算法的运行时间不随输入规模的变化而变化，通常用于描述那些对输入数据规模不敏感的操作。

- **线性时间复杂度：O(n)**  
   运行时间与输入规模成正比，意味着输入数据量增加一倍，运行时间也大致增加一倍。

- **对数线性时间复杂度：O(n log2 n)**  
   这是许多高效排序算法（如归并排序和快速排序）的时间复杂度，表示运行时间增长速度介于线性和平方之间。其中 log2 n 表示以 2 为底的 n 的对数。

- **平方时间复杂度：O(n²)**  
   运行时间与输入规模的平方成正比，常见于简单排序算法如冒泡排序和选择排序。

### 1.3 空间复杂度

排序算法的空间复杂度是指算法在运行过程中所需额外内存空间的大小，它同样用 **“大O符号”** 表示。空间复杂度考虑的是算法在处理数据时占用的内存量，特别是与输入规模相关的额外内存使用。

根据以上因素，常见的空间复杂度分类如下：

- **O(1)（常数空间复杂度）**：算法运行所需的额外空间是固定的，不随输入规模的变化而变化。许多原地排序算法，如堆排序和快速排序（不考虑递归栈空间），属于这种。

- **O(n)（线性空间复杂度）**：算法所需的额外空间与输入规模成正比。比如归并排序，由于需要额外的数组来合并子数组，其空间复杂度为O(n)。

- **O(log2 n)**：一些递归算法（如某些优化的快速排序实现）在使用递归调用时，其递归栈的深度是对数级的，因此空间复杂度为O(log2 n)。

### 1.4 分治法（Divide and Conquer

分治法是一种算法设计范式，它将一个复杂的问题分解为多个较小的子问题，递归地解决这些子问题，然后将它们的结果合并以得到原问题的解。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序）。

## 2 排序算法

### 2.1 冒泡排序（Bubble Sort）

**稳定性** ：

稳定

**实现原理** ：

- 从数组的起始位置开始，依次比较相邻的两个元素。如果前一个元素比后一个元素大（对于升序排序），就交换这两个元素
- 对每一对相邻元素进行比较和交换之后，最大的元素会被移动到数组的末尾
- 忽略数组中已经排好的最后一个元素，对剩下的元素重复上述步骤，直到没有元素需要交换，此时说明数组已经有序，可以结束排序

**动图演示** ：

![01_bubble_sort](/assets/images/2022/2022-02-16-SortAlgorithm/01_bubble_sort.gif)

**时间复杂度** ：

1. **最佳情况（已经有序的数组）**：O(n)
   - 当数组已经有序时，冒泡排序只需要进行一次遍历来确认数组是有序的，因此时间复杂度为 O(n)。

2. **平均情况**：O(n²)
   - 在一般情况下，冒泡排序需要进行多次遍历和比较，平均时间复杂度为 O(n²)。

3. **最坏情况（逆序的数组）**：O(n²)
   - 在最坏的情况下，数组是完全逆序的，每次都需要进行最大次数的比较和交换，因此时间复杂度为 O(n²)。

**空间复杂度** ：

冒泡排序的空间复杂度为 O(1)，因为它是就地排序算法，不需要额外的存储空间。它只需要常量级别的额外空间来存储临时变量用于交换元素。

**代码实现** ：

```c++
// 冒泡排序
void BubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    // 重复遍历待排序数组
    for (int i = 0; i < n - 1; ++i) {
        bool swapped = false;
        // 比较相邻的元素，当前一个元素大于后一个元素时，交换它们。
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果在某次遍历中没有发生任何交换，则说明数组已经有序，可以提前结束排序
        if (!swapped) {
            break;
        }
    }
}
```

### 2.2 选择排序（Selection Sort）

**稳定性** ：

不稳定

**实现原理** ：

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾

- 重复第二步，直到所有元素均排序完毕

**动图演示** ：

![06_selection_sort](/assets/images/2022/2022-02-16-SortAlgorithm/06_selection_sort.gif)

**时间复杂度** ：

选择排序的时间复杂度在最坏、平均和最好情况下都是 O(n²)

**空间复杂度** ：

选择排序的空间复杂度是 O(1) 。这是因为选择排序是一种原地排序算法，它只需要常量级别的额外空间来存储临时变量，用于交换元素。

**代码实现** ：

```c++
void SelectionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        // 假设当前第 i 个元素是最小的
        int minIndex = i;
        // 在未排序部分寻找最小元素
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换找到的最小元素和当前元素
        std::swap(arr[i], arr[minIndex]);
    }
}
```

### 2.3 插入排序（Insertion Sort）

**稳定性** ：

稳定

**实现原理** ：

- 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列
- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

**动图演示** ：

![07_insertion_sort](/assets/images/2022/2022-02-16-SortAlgorithm/07_insertion_sort.gif)

**时间复杂度** ：

插入排序的时间复杂度取决于输入数据的初始顺序：

1. **最坏情况**：O(n²)
   - 当输入数组是反序时，每次插入操作都需要将新元素与已经排序的元素逐一比较并移动，因此比较和移动操作的次数达到最大

2. **平均情况**：O(n²)
   - 对于随机排列的数组，插入排序的性能通常介于最好和最坏情况之间，平均来说是二次复杂度

3. **最好情况**：O(n)
   - 当输入数组已经是有序的情况下，插入排序只需进行 \(n-1\) 次比较而无需移动元素，因此其时间复杂度为线性

**空间复杂度** ：

插入排序的空间复杂度是 O(1) 。这是因为插入排序是一种原地排序算法，它只需要常量级别的额外空间来存储临时变量（用于在插入过程中进行元素交换）。整个排序过程直接在输入数组上进行，不需要使用额外的数据结构，因此空间复杂度为常数级别。

**代码实现** ：

```c++
void InsertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;
        // 将大于 key 的元素向右移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 插入 key 到正确的位置
        arr[j + 1] = key;
    }
}
```

### 2.4 归并排序（Merge Sort）

**稳定性** ：

稳定

**实现原理** ：

- **递归** 地将待排序数组从中间分成两个子数组，直到每个子数组的元素数量为 1
- 每次将数组分成两个子数组后，合并这两个子数组，合并的过程是通过比较两个子数组的元素，依次将较小的元素放入结果数组中

**动图演示** ：

![02_merge_sort](/assets/images/2022/2022-02-16-SortAlgorithm/02_merge_sort.gif)

**时间复杂度** ：

1. **最佳情况**：O(n log2 n)
2. **平均情况**：O(n log2 n)
3. **最坏情况**：O(n log2 n)

归并排序的时间复杂度为 O(n log2 n) 的原因在于：

- 归并排序将待排序的数组不断地分成两半，直到每个子数组只包含一个元素。这一过程需要 log2 n 次分割。
- 在每次合并操作中，需要线性时间 O(n) 来合并两个子数组。

**空间复杂度** ：

归并排序的空间复杂度为 O(n)，因为归并过程中需要额外的存储空间来存放临时合并的结果。

**代码实现** ：

```c++
// 合并两个子数组
void Merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // 创建临时数组
    std::vector<int> leftArr(n1);
    std::vector<int> rightArr(n2);

    // 将数组拷贝到临时数组
    for (int i = 0; i < n1; ++i) {
        leftArr[i] = arr[left + i];
    }
    for (int j = 0; j < n2; ++j) {
        rightArr[j] = arr[mid + 1 + j];
    }

    // 合并临时数组到原数组
    int i = 0, j = 0;
    int k = left;
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    // 拷贝剩余元素（如果有）
    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

// 递归实现归并排序
void MergeSort(std::vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        // 递归排序两个子数组
        MergeSort(arr, left, mid);
        MergeSort(arr, mid + 1, right);

        // 合并两个已排序的子数组
        Merge(arr, left, mid, right);
    }
}
```

### 2.5 快速排序（Quick Sort）

**稳定性** ：

不稳定

**实现原理** ：

通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有元素都比另一部分的所有元素小，然后对这两部分分别继续进行快速排序。

1. **选择基准（Pivot）**
    - 从数组中选择一个元素作为 **基准（Pivot）** 。选择基准的方法可以有多种，包括选择第一个元素、最后一个元素、随机选择一个元素，或者选择中间位置的元素

2. **分区（Partition）**
    - 将数组重新排列，使得所有比基准小的元素放在基准的左边，所有比基准大的元素放在基准的右边。经过这一步骤后，基准元素处于其最终位置上

3. **递归排序**
    - 对基准左边和右边的子数组分别递归进行快速排序。

**动图演示** ：

![03_quick_sort](/assets/images/2022/2022-02-16-SortAlgorithm/03_quick_sort.gif)

**时间复杂度** ：

快速排序的时间复杂度依赖于选取的基准（pivot）以及数据的初始顺序。具体分析如下：

1. **最佳情况**：O(n log2 n)
   - 当每次选择的基准能够将数组均匀地分成两部分时，快速排序的时间复杂度为 O(n log2 n)。这是因为数组被递归地分成两部分，每一层的工作量是 O(n)，而递归的深度是 O(log2 n)。

2. **平均情况**：O(n log2 n)
   - 在平均情况下，快速排序的时间复杂度也是 O(n log2 n)。随机选择基准或者使用一些改进方法（如三数取中）可以使得快速排序在平均情况下表现良好。

3. **最坏情况**：O(n²)
   - 当每次选择的基准都导致极不均匀的分割（例如每次都选择最大或最小的元素作为基准），快速排序的时间复杂度会退化为 O(n²)。这种情况通常出现在已经有序或接近有序的数组上。

**空间复杂度** ：

快速排序的空间复杂度主要由递归调用栈的深度决定。具体来说：

1. **最佳情况**：O(log2 n)
   - 当每次分割都将数组均匀地分成两部分时，递归调用栈的深度为 O(log2 n)。因此，快速排序在这种情况下的空间复杂度是 O(log2 n)。

2. **平均情况**：O(log2 n)
   - 在平均情况下，快速排序的递归调用深度接近于最佳情况，空间复杂度仍然为 O(log2 n)。

3. **最坏情况**：O(n)
   - 在最坏情况下（例如，每次选择的基准总是数组的最大或最小元素），递归调用栈的深度会达到 O(n)，因此空间复杂度为 O(n)。这种情况通常发生在数组已经有序或接近有序的情况下。

**代码实现** ：

```c++
// 进行数组的划分
int Partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 选择最后一个元素为基准值
    int i = low - 1; // i 是小于基准值的最后一个元素的索引

    for (int j = low; j < high; ++j) {
        if (arr[j] < pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    // 将基准值放到正确的位置
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

// 快速排序
void QuickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 得到划分点
        int pi = Partition(arr, low, high);

        // 递归排序划分点左边的子数组和右边的子数组
        QuickSort(arr, low, pi - 1);
        QuickSort(arr, pi + 1, high);
    }
}
```

### 2.6 堆排序（Heap Sort）

堆排序是一种基于 **堆数据结构** 的比较排序算法。

堆是一种特殊的完全二叉树，分为 **大顶堆** 和 **小顶堆** ：

- **大顶堆** ：每个节点的值都大于或等于其子节点的值
- **小顶堆** ：每个节点的值都小于或等于其子节点的值

堆的存储结构：

![05_heap_data](/assets/images/2022/2022-02-16-SortAlgorithm/05_heap_data.jpeg)

堆排序一般使用大顶堆来进行升序排序。

**稳定性** ：

不稳定

**实现原理** ：

1. **构建最大堆**：将待排序数组构造成一个大顶堆
2. **交换堆顶元素和堆的最后一个元素**：这样最大元素就被放到了数组的末尾
3. **减少堆的大小**，并对堆顶进行堆化，以维持大顶堆性质
4. **重复步骤 2 和 3**，直到堆的大小为1

**动图演示** ：

![04_heap_sort](/assets/images/2022/2022-02-16-SortAlgorithm/04_heap_sort.gif)

**时间复杂度** ：

堆排序的时间复杂度在不同情况下都是一致的：

1. **最佳情况**：O(n log2 n)
2. **平均情况**：O(n log2 n)
3. **最坏情况**：O(n log2 n)

堆排序的时间复杂度为 O(n log2 n) 的原因在于：

- 建堆过程的时间复杂度为 O(n)。在这一步中，将输入数组转化为一个最大堆
- 之后进行 n 次删除操作，每次删除堆顶元素（即当前最大元素）并进行堆调整。每次堆调整的时间复杂度为 O(log2 n)，因此删除操作的总时间复杂度为 O(n log2 n)

**空间复杂度** ：

堆排序的空间复杂度为 O(1)。这是因为堆排序是就地排序（in-place sorting），不需要额外的数组或存储空间来进行排序操作。它直接在输入数组上进行元素的比较和交换，从而实现排序。

**代码实现** ：

```c++
// 维护堆性质
void Heapify(std::vector<int>& arr, int n, int i) {
    int largest = i; // 初始化最大值为根节点
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点

    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // 如果右子节点大于最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果最大值不是根节点
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        // 递归地调整受影响的子树
        Heapify(arr, n, largest);
    }
}

// 堆排序
void HeapSort(std::vector<int>& arr) {
    int n = arr.size();

    // 构建大顶堆
    for (int i = n / 2 - 1; i >= 0; --i) {
        Heapify(arr, n, i);
    }

    // 一个个从堆中取出元素
    for (int i = n - 1; i > 0; --i) {
        // 移动当前根到末尾
        std::swap(arr[0], arr[i]);
        // 调整堆
        Heapify(arr, i, 0);
    }
}
```

### 2.7 希尔排序（Shell Sort）

希尔排序是[插入排序](#23-插入排序insertion-sort)的一种改进版本，也被称为 **缩小增量排序** 。其基本思想是：将数组分成若干个子序列，使得每个子序列内的元素是相隔一定步长（Gap Sequence）的，然后在每个子序列内进行插入排序。随着算法的进行，步长逐渐减小，最后一步步长为1时，整个数组就是有序的。

**稳定性** ：

不稳定

**实现原理** ：

1. **选择初始步长**：选择一个小于数组长度的步长序列（例如，希尔排序的原始步长序列是数组长度的一半逐步减小）

2. **按步长分组**：将数组元素按步长分组，对组内元素进行插入排序

3. **逐步减小步长**：重复步骤2，逐步减小步长，直到步长为 1

4. **最终排序**：当步长减小到 1 时，再对整个数组进行一次插入排序

**动图演示** ：

![08_shell_sort](/assets/images/2022/2022-02-16-SortAlgorithm/08_shell_sort.gif)

**时间复杂度** ：

根据步长序列的不同而不同，已知最好的情况接近 O(n log2 n) 。

**空间复杂度** ：

希尔排序的空间复杂度是 O(1) 。这是因为希尔排序是一种原地排序算法，它在排序过程中只需要使用常量级别的额外空间来存储临时变量。所有的排序操作都是在输入数组上直接进行的，因此不需要额外的内存来存储数据。

**代码实现** ：

```c++
void ShellSort(std::vector<int>& arr) {
    int n = arr.size();
    // 选择步长序列，这里使用希尔增量
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 从步长处开始进行插入排序
        for (int i = gap; i < n; ++i) {
            int temp = arr[i];
            int j;
            // 对每个步长子序列进行插入排序
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}
```

### 2.8 计数排序（Counting Sort）

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。计数排序适用于元素是整数且范围不大的情况。

**稳定性** ：

稳定

**实现原理** ：

1. **确定范围**：找出待排序数组中的最大值和最小值，以确定计数数组的大小

2. **计数**：创建一个计数数组，数组的长度为（最大值-最小值+1）。遍历原始数组，对于每个元素，增加计数数组中对应位置的计数值

3. **累加计数**：对计数数组进行累加操作，这样计数数组的每个位置就表示原数组中小于或等于该索引值的元素个数

4. **排序输出**：创建一个输出数组，通过遍历原始数组，从计数数组中找到元素的正确位置，并将其放入输出数组。每放入一个元素就减少计数数组中相应位置的计数值

**动图演示** ：

![09_counting_sort](/assets/images/2022/2022-02-16-SortAlgorithm/09_counting_sort.gif)

**时间复杂度** ：

计数排序的时间复杂度是 O(n + k)，其中 (n) 是元素的数量，(k) 是元素的范围（最大值减去最小值）。

**空间复杂度** ：

计数排序的空间复杂度是 O(n + k)，其中 (n) 是元素的数量，(k) 是元素的范围（最大值减去最小值）。

**代码实现** ：

```c++
// 计数排序函数
void CountingSort(std::vector<int>& arr) {
    // 如果数组为空，直接返回
    if (arr.empty()) return;

    // 找到数组中的最小值和最大值
    int minVal = *std::min_element(arr.begin(), arr.end());
    int maxVal = *std::max_element(arr.begin(), arr.end());

    // 创建计数数组，范围是最大值减最小值再加1
    int range = maxVal - minVal + 1;
    std::vector<int> count(range, 0);

    // 统计每个元素的出现次数
    for (int num : arr) {
        count[num - minVal]++;
    }

    // 修改计数数组，使其存储的值为小于或等于该索引元素的个数
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }

    // 创建输出数组以存储排序后的结果
    std::vector<int> output(arr.size());

    // 从后向前遍历原始数组，构建输出数组
    for (int i = arr.size() - 1; i >= 0; i--) {
        // 将元素放到正确位置，并减少计数
        output[--count[arr[i] - minVal]] = arr[i];
    }

    // 将排序后的结果复制回原数组
    arr = output;
}
```

### 2.9 桶排序（Bucket Sort）

桶排序是一种基于分布的排序算法，其基本思想是将数组元素分布到有限数量的桶中，然后对每个桶中的元素分别进行排序，最后将所有桶中的元素合并得到有序数组。

**稳定性** ：

稳定

**实现原理** ：

1. **确定桶的数量和范围**：根据数据的范围和分布情况，将数据分到一定数量的桶中

2. **分配到桶**：遍历输入数据，根据每个元素的大小，将其放入对应的桶中

3. **桶内排序**：对每个桶中的元素进行排序。可以使用任何适合的排序算法，如快速排序、插入排序等

4. **合并结果**：将所有桶中的排序结果合并成一个有序数组

**动图演示** ：

![10_bucket_sort](/assets/images/2022/2022-02-16-SortAlgorithm/10_bucket_sort.gif)

**时间复杂度** ：

桶排序的时间复杂度取决于几个因素，包括数据的分布情况、桶的数量以及桶内使用的排序算法。通常，桶排序在以下情况下表现最佳：

1. **平均时间复杂度**：O(n + k)，其中 n 是输入数据的数量，k 是桶的数量。平均情况下，假设数据均匀分布，每个桶内的元素数量较少，因此可以在线性时间内完成排序

2. **最佳时间复杂度**：O(n)，在理想情况下，如果数据均匀分布，且每个桶内的元素数量接近相同，桶排序可以在接近线性时间内完成

3. **最坏时间复杂度**：O(n^2)，在最坏情况下，如果所有元素被分配到一个桶中，那么桶内的排序将退化为对该桶中的元素进行排序的复杂度。例如，如果桶内使用的排序算法是快速排序，最坏情况下的复杂度是 O(n^2)

**空间复杂度** ：

桶排序的空间复杂度主要由以下几个部分构成：

1. **桶的存储**：需要额外的空间来存储桶。假设有 k 个桶，每个桶平均存储 n/k 个元素，其中 n 是输入数据的数量。桶的总空间复杂度为 O(n + k)，因为我们需要为每个元素分配空间，并且每个桶可能需要额外的一些固定空间。

2. **临时存储**：在某些实现中，可能需要额外的临时存储空间来处理数据的归一化或其他操作，但这通常是常数级别的，不显著影响总体空间复杂度。

因此，桶排序的空间复杂度可以表示为 O(n + k)，其中 n 是输入数据的数量，k 是桶的数量。在大多数实现中，桶的数量 k 通常是与 n 成比例的常量，因此可以简化为 O(n) 的空间复杂度。

**代码实现** ：

```c++
// 桶排序
void BucketSort(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 0)
        return;

    // 找到数组中的最大值和最小值
    float minValue = *std::min_element(arr.begin(), arr.end());
    float maxValue = *std::max_element(arr.begin(), arr.end());

    // 计算每个桶的范围
    float range = (maxValue - minValue) / n;

    // 创建 n 个空桶
    std::vector<std::vector<float>> buckets(n);

    // 将数组元素放入对应的桶中
    for (int i = 0; i < n; ++i) {
        int bucketIndex = static_cast<int>((arr[i] - minValue) / range);
        if (bucketIndex == n) {  // 处理最大值的边界情况
            bucketIndex--;
        }
        buckets[bucketIndex].push_back(arr[i]);
    }

    // 对每个桶进行排序
    for (int i = 0; i < n; ++i) {
        std::sort(buckets[i].begin(), buckets[i].end());
    }

    // 合并所有桶中的元素
    int index = 0;
    for (int i = 0; i < n; ++i) {
        for (size_t j = 0; j < buckets[i].size(); ++j) {
            arr[index++] = buckets[i][j];
        }
    }
}
```

### 2.10 基数排序（Radix Sort）

**稳定性** ：

稳定

**实现原理** ：

1. 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
2. 从最低位开始，依次进行一次排序
3. 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

**动图演示** ：

![11_radix_sort](/assets/images/2022/2022-02-16-SortAlgorithm/11_radix_sort.gif)

**时间复杂度** ：

基数排序的时间复杂度主要取决于三个因素：输入数组的大小 ( n )、最大数的位数 ( d )、以及使用的基数 ( k )（例如，对于十进制数，( k = 10 )）。基数排序的时间复杂度可以表示为： O(d (n + k)) 。

**空间复杂度** ：

基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量。一般来说 n >> k ，因此额外空间需要大概 n 个左右。

**代码实现** ：

```c++
// 获取数组中最大值的位数
int GetMax(const std::vector<int>& arr) {
    int maxVal = *std::max_element(arr.begin(), arr.end());
    return maxVal;
}

// 使用计数排序对数组 arr 按照 exp 位进行排序
void CountingSort(std::vector<int>& arr, int exp) {
    int n = arr.size();
    std::vector<int> output(n);  // 输出数组
    int count[10] = {0};

    // 计算每个数字在 exp 位上的出现次数
    for (int i = 0; i < n; i++) {
        int index = (arr[i] / exp) % 10;
        count[index]++;
    }

    // 将 count[i] 修改为包含实际位置的前缀和
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // 从后向前构建输出数组，确保稳定排序
    for (int i = n - 1; i >= 0; i--) {
        int index = (arr[i] / exp) % 10;
        output[count[index] - 1] = arr[i];
        count[index]--;
    }

    // 将排序结果复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

// 基数排序
void RadixSort(std::vector<int>& arr) {
    int maxVal = GetMax(arr);

    // 从最低有效位开始，对每个位进行计数排序
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        CountingSort(arr, exp);
    }
}
```

## 参考

- [1] [10大经典排序算法动图演示，看这篇就够了！（配相应代码）](https://www.cnblogs.com/aishangJava/p/10092341.html)
- [2] [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)
- [3] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)

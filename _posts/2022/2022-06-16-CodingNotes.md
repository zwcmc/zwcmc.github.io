---
layout: post
title:  "代码技巧"
date:   20166-02-16 12:16:00 PM
category: Coding
---

## 目录

- [目录](#目录)
- [(1) 将两个 16 位无符号整数编码成一个 32 位无符号整数](#1-将两个-16-位无符号整数编码成一个-32-位无符号整数)

## (1) 将两个 16 位无符号整数编码成一个 32 位无符号整数

我们知道，一个无符号整数 `unsigned int` 在内存中占用 4 个 **字节（Byte）** ， 1 个字节是 8 **位（Bit）** ，也就是说一个无符号整数有 32 位。而一个无符号短整数 `unsigned short` 在内存中占用 2 个字节，也就是 16 位。

通过 **位操作** ，我们可以将两个无符号短整数编码成一个无符号整数，分别将这两个无符号短整数存储在无符号整数的低 16 位和高 16 位。

当然，**如果有两个无符号整数，它们的数值大小在 0 到 65535 之间**（无符号短整数一共 16 位，而 2^16 = 65536 ，所以 16 位可以表示的最大数是 65535），这表明这两个无符号整数的高 16 位都是没有使用的，此时也可以通过位操作将两个无符号整数编码成一个无符号整数存储，以达到节省内存带宽的目的。

下面就以两个无符号整数示例，来将它们编码位一个无符号整数。

**编码函数**：

```cpp
uint32_t Encode(uint32_t min, uint32_t max) {
    return (min & 0xFFFF) | ((max & 0xFFFF) << 16);
}
```

分析：

- `(min & 0xFFFF)` ：使用 **按位与操作符** `&` 将 `min` 的低 16 位保留下来
- `(max & 0xFFFF) << 16` ：首先，也是通过按位与操作符将 `max` 的低 16 位保留下来，高 16 位会被清零。然后将其左移 16 位，使其移动到 32 位无符号整数的高 16 位
- 最后，通过**按位或操作符** `|` 将 `min` 保留下来的低 16 位与上一步空出来的低 16 位组合，最终输出一个 32 位无符号整数，其中高 16 位存储的是 `max` 值，低 16 位存储的是 `min` 值

**解码函数**：

```cpp
void Decode(uint32_t encoded, uint32_t* min, uint32_t* max) {
    *min = (encoded & 0xFFFF);
    *max = (encoded >> 16) & 0xFFFF;
}
```

分析：

- `(encoded & 0xFFFF)` ： `min` 存储在无符号 32 位整数 `encoded` 的低 16 位，直接使用按位与操作符将低 16 位提取出来，它的结果对应就是 `min` 值
- `(encoded >> 16) & 0xFFFF` ：先将无符号 32 位整数 `encoded` 右移 16 位，将高 16 位移动到低 16 位，再通过按位与操作符将低 16 位提取出来，也就是 `max` 的值
